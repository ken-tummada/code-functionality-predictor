{"x": ["def multiply(b, c):\n    if b == 0 or c == 0:\n        return 0\n    \n    if b < 0:\n        b = ~b + 1  # convert b to positive\n    if c < 0:\n        c = ~c + 1  # convert c to positive\n    \n    result = 0\n    mask = 1\n    \n    while c != 0:\n        if c & 1:\n            result += b\n        \n        b <<= 1\n        c >>= 1\n        mask <<= 1\n    \n    if (b ^ c) < 0:  # if either b or c is negative\n        result = ~result + 1  # convert result to negative\n    \n    return result\n\nb = 5\nc = 7\nprint(multiply(b, c))  # Output: 35\n\nb = -3\nc = 4\nprint(multiply(b, c))  # Output: -12\n\nb = 9\nc = 0\nprint(multiply(b, c))  # Output: 0", "print(isValid(\"()\")) # Expected: True\nprint(isValid(\"()[]{}\")) # Expected: True\nprint(isValid(\"(]\")) # Expected: False\nprint(isValid(\"([)]\")) # Expected: False\nprint(isValid(\"{[]}\")) # Expected: True\nprint(isValid(\"{[()()]}\")) # Expected: True\nprint(isValid(\"{[(])}\")) # Expected: False"], "preds": ["This function implements integer multiplication using the classical shift-and-add (Russian peasant) algorithm so you can multiply two integers without using the built-in multiplication operator: it repeatedly adds the multiplicand to a running result whenever the current least-significant bit of the multiplier is 1, left-shifts the multiplicand and right-shifts the multiplier, and stops when the multiplier becomes zero. Inputs: two signed integers (b, c); output: their integer product. Core components are: an initial zero-check shortcut, conversion of negative inputs to their magnitudes using two's-complement negation (~x + 1), an iterative loop that inspects c & 1 to decide when to add b to result, bit-shifts (b <<= 1, c >>= 1) to progress the algorithm, and a final sign correction intended to negate the result if exactly one input was negative. Complexity is O(number of bits in the multiplier) time and O(1) extra space. Implementation caveats and recommended fixes/adaptations: store original signs (e.g. sign = (b < 0) ^ (c < 0)) before converting to absolute values or just use abs(), remove the unused mask variable, and apply the sign at the end (if sign then result = -result); on fixed-width languages you must use logical right-shift for the multiplier magnitude and mask/clip intermediate values to avoid overflow and preserve two's-complement semantics; in arbitrary-precision languages like Python you can use abs() and normal shifts and watch for performance if inputs are huge. Edge cases: handle zero early, ensure correct handling of INT_MIN in fixed-width implementations (abs(INT_MIN) requires special care), and validate input types if used in mixed-type contexts.", "This code implements a parentheses/bracket validator: given an input string composed of the three bracket types '()', '[]', '{}' it returns a boolean indicating whether brackets are correctly paired and properly nested (examples in the tests show expected True/False results). The intended use case is syntax-like validation of bracket sequences (e.g., simple parser pre-checks), not full language parsing. Core behavior: scan the input left-to-right using a stack; push opening brackets, and on encountering a closing bracket check that the stack is non-empty and its top element is the matching opening bracket (using a small mapping from closing\u2192opening); if a mismatch or empty stack occurs return False immediately; after the scan return True only if the stack is empty. Typical implementation details: accept a string s, optionally short-circuit on odd length, maintain a dictionary/map {')':'(',']':'[','}':'{'} and a stack (list) for O(n) time and O(n) space complexity; treat an empty string as valid. To adapt, either ignore or treat non-bracket characters as invalid depending on requirements, extend the mapping to additional bracket types or Unicode pairs, or convert to a streaming/iterator-friendly version that processes input chunks and preserves stack state across calls."]}