{"x": ["import jsonschema\nimport json\n\nclass User:\n    schema = {\n        \"type\" : \"object\",\n        \"properties\" : {\n            \"firstName\" : {\n                \"type\" : \"string\"\n            },\n            \"lastName\" : {\n                \"type\" : \"string\"\n            },\n            \"age\" : {\n                \"description\" : \"Age in years\",\n                \"type\" : \"integer\",\n                \"minimum\" : 0\n            }\n        },\n        \"required\" : [\"firstName\", \"lastName\"]\n    }\n    \n    def __init__(self, firstName, lastName, age=None):\n        self.firstName = firstName\n        self.lastName = lastName\n        self.age = age\n        # validate the input JSON against the schema\n        jsonschema.validate(self.toJson(), User.schema)\n    \n    def toJson(self):\n        # returns a json representation of the user object.\n        return json.dumps(self.__dict__)", "def is_vowel(ch):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return ch.lower() in vowels\n\nmorse_code = {\n    'B': '-...',\n    'C': '-.-.',\n    'D': '-..',\n    'F': '..-.',\n    'G': '--.',\n    'H': '....',\n    'J': '.---',\n    'K': '-.-',\n    'L': '.-..',\n    'M': '--',\n    'N': '-.',\n    'P': '.--.',\n    'Q': '--.-',\n    'R': '.-.',\n    'S': '...',\n    'T': '-',\n    'V': '...-',\n    'W': '.--',\n    'X': '-..-',\n    'Y': '-.--',\n    'Z': '--..'\n}\n\ndef convert_string(s):\n    result = ''\n    for ch in s:\n        if not ch.isalpha():\n            continue\n        if is_vowel(ch):\n            result += ch.upper()\n        else:\n            result += morse_code[ch.upper()]\n    return result"], "preds": ["This module implements a small data-model and runtime JSON-schema validation wrapper for a User entity: it defines a class-level JSON Schema (object with properties firstName:string, lastName:string, and optional age:integer >= 0; firstName and lastName are required) and exposes a constructor that accepts firstName, lastName and optional age, validates the instance against that schema, and provides a serializer method that returns a JSON string representation of the instance. Intended use is in applications that need lightweight in-process validation/serialization of user-like records before further processing, storage, or transmission; instantiation will raise jsonschema.ValidationError on schema violations. Key technical components/dependencies are the jsonschema library for validation and the standard json library for serialization; the implementation should construct a Python dict representing the object, call jsonschema.validate(instance=dict, schema=User.schema) (note: validate expects a Python object, not a JSON string), then store attributes and optionally return json.dumps(dict) from a to_json/toJson method. To adapt or reimplement, keep the schema as a canonical source of truth (class constant), perform validation on the native dict form, decide whether to return dicts or strings from serializers, add error handling or custom validators, and extend the schema for extra fields, defaults, type coercion, or immutability as needed.", "This code implements a simple text transformer that scans an input string and produces a single concatenated output where alphabetic vowels (a, e, i, o, u) are preserved as uppercase letters and alphabetic consonants are replaced with their Morse-code representations (dot/dash strings) from a hard-coded dictionary; all non-alphabetic characters are dropped. Inputs: any Python string; outputs: a single string containing uppercase vowels and Morse code tokens concatenated without separators. Key components: an is_vowel predicate using a small vowel set, a morse_code dict mapping uppercase consonants B\u2013Z (vowels intentionally omitted) to Morse sequences, and convert_string(s) which filters non-alpha chars, branches on vowel vs consonant, and appends the corresponding token. Complexity is linear O(n) in input length (note current code uses repeated string concatenation which is O(n^2) in some languages \u2014 in Python prefer list append + join for large inputs). Implementation notes and adaptations: to make it robust, supply a full A\u2013Z Morse map or use dict.get to avoid KeyError on unexpected alphabetic/unicode letters, optionally preserve word boundaries by inserting separators (space, slash) between letters/words, make vowel set configurable, and handle Unicode alphabets explicitly if needed; add unit tests for punctuation, mixed-case, and non-Latin characters."]}