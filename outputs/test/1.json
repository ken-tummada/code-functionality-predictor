{"x": ["import jsonschema\nimport json\n\nclass User:\n    schema = {\n        \"type\" : \"object\",\n        \"properties\" : {\n            \"firstName\" : {\n                \"type\" : \"string\"\n            },\n            \"lastName\" : {\n                \"type\" : \"string\"\n            },\n            \"age\" : {\n                \"description\" : \"Age in years\",\n                \"type\" : \"integer\",\n                \"minimum\" : 0\n            }\n        },\n        \"required\" : [\"firstName\", \"lastName\"]\n    }\n    \n    def __init__(self, firstName, lastName, age=None):\n        self.firstName = firstName\n        self.lastName = lastName\n        self.age = age\n        # validate the input JSON against the schema\n        jsonschema.validate(self.toJson(), User.schema)\n    \n    def toJson(self):\n        # returns a json representation of the user object.\n        return json.dumps(self.__dict__)", "def is_vowel(ch):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return ch.lower() in vowels\n\nmorse_code = {\n    'B': '-...',\n    'C': '-.-.',\n    'D': '-..',\n    'F': '..-.',\n    'G': '--.',\n    'H': '....',\n    'J': '.---',\n    'K': '-.-',\n    'L': '.-..',\n    'M': '--',\n    'N': '-.',\n    'P': '.--.',\n    'Q': '--.-',\n    'R': '.-.',\n    'S': '...',\n    'T': '-',\n    'V': '...-',\n    'W': '.--',\n    'X': '-..-',\n    'Y': '-.--',\n    'Z': '--..'\n}\n\ndef convert_string(s):\n    result = ''\n    for ch in s:\n        if not ch.isalpha():\n            continue\n        if is_vowel(ch):\n            result += ch.upper()\n        else:\n            result += morse_code[ch.upper()]\n    return result"], "preds": ["This module defines a simple Python User model intended for creating, validating and serializing user records against a JSON Schema: the User class contains a class-level JSON Schema requiring string firstName and lastName and an optional integer age >= 0; its constructor accepts firstName, lastName and optional age, assigns them to instance attributes and performs schema validation, and it exposes a toJson() method that returns a JSON string of the instance state. Key technical points for reimplementation or adaptation: depend on the jsonschema and json libraries, keep the schema as a class-level dict so it can be reused or extended, accept inputs as native Python types (str and int), and validate using jsonschema.validate(instance_dict, schema) \u2014 note the provided code calls validate on a JSON string (json.dumps(self.__dict__)), which is incorrect; instead validate the Python dict (self.__dict__ or an explicit to_dict() result) to get correct type checking and to raise jsonschema.ValidationError on invalid input. For robust production use, expose separate to_dict() and to_json() methods, perform validation before or immediately after constructing the dict to avoid partially-initialized objects, handle or translate validation exceptions, optionally strip None fields from serialized output, and consider using dataclasses or a schema-driven library (pydantic) if you need coercion, richer typing, default values, or schema versioning.", "This module implements a simple ASCII-letter encoder that scans an input string and produces a compact encoded string where vowel characters (A, E, I, O, U) are preserved as uppercase letters and consonants are replaced by their Morse-code sequences (dots and dashes) concatenated together; non-letter characters are ignored. Intended use cases are lightweight text transformations or toy encoders where vowels should remain readable and consonants conveyed in Morse without inter-letter separators (i.e., the output is a single concatenated string). Core components: an is_vowel predicate that checks membership against the vowel set (case-insensitive), a morse_code mapping from uppercase consonant letters to Morse strings, and convert_string(s) which iterates the input, drops non-letters, emits uppercase vowel letters or the morse_code entry for consonants, and returns the concatenated result. Inputs: any string; outputs: a single string. Key behaviors and constraints: case-insensitive recognition of input letters, vowels emitted as uppercase ASCII letters, consonants emitted as dot/dash sequences, no separators between emitted tokens (which creates potential decoding ambiguity), and non-ASCII alphabetic characters will be filtered by isalpha() but may cause KeyError if their uppercase form is not present in the morse map. Complexity is linear in input length. Implementation/adaptation notes: reimplement by iterating characters, using ch.isalpha() then ch.lower()/ch.upper() checks; build tokens into a list and join for efficiency; consider using morse_code.get(key, fallback) to avoid KeyError, parameterize the vowel set, add configurable separators between tokens or words for decodability, extend the mapping to digits/punctuation or international alphabets, and add unit tests for edge cases (empty input, non-ASCII letters, and missing mapping entries)."]}