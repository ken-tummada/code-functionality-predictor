{"x": ["import jsonschema\nimport json\n\nclass User:\n    schema = {\n        \"type\" : \"object\",\n        \"properties\" : {\n            \"firstName\" : {\n                \"type\" : \"string\"\n            },\n            \"lastName\" : {\n                \"type\" : \"string\"\n            },\n            \"age\" : {\n                \"description\" : \"Age in years\",\n                \"type\" : \"integer\",\n                \"minimum\" : 0\n            }\n        },\n        \"required\" : [\"firstName\", \"lastName\"]\n    }\n    \n    def __init__(self, firstName, lastName, age=None):\n        self.firstName = firstName\n        self.lastName = lastName\n        self.age = age\n        # validate the input JSON against the schema\n        jsonschema.validate(self.toJson(), User.schema)\n    \n    def toJson(self):\n        # returns a json representation of the user object.\n        return json.dumps(self.__dict__)", "def is_vowel(ch):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return ch.lower() in vowels\n\nmorse_code = {\n    'B': '-...',\n    'C': '-.-.',\n    'D': '-..',\n    'F': '..-.',\n    'G': '--.',\n    'H': '....',\n    'J': '.---',\n    'K': '-.-',\n    'L': '.-..',\n    'M': '--',\n    'N': '-.',\n    'P': '.--.',\n    'Q': '--.-',\n    'R': '.-.',\n    'S': '...',\n    'T': '-',\n    'V': '...-',\n    'W': '.--',\n    'X': '-..-',\n    'Y': '-.--',\n    'Z': '--..'\n}\n\ndef convert_string(s):\n    result = ''\n    for ch in s:\n        if not ch.isalpha():\n            continue\n        if is_vowel(ch):\n            result += ch.upper()\n        else:\n            result += morse_code[ch.upper()]\n    return result"], "preds": ["This module defines a simple User model that enforces a JSON Schema-based contract at construction and can serialize itself to JSON; intended use is lightweight input validation and serialization for services that accept or emit user records. The core components are: a class-level JSON Schema (User.schema) describing an object with required string properties firstName and lastName and an optional integer age with minimum 0; a constructor that takes firstName, lastName, and optional age, assigns them to instance attributes and runs jsonschema.validate against the instance; and a toJson() method that returns a JSON string of the instance state (via json.dumps(self.__dict__)). Behavior: constructing a User will raise jsonschema.ValidationError if the instance does not satisfy the schema, and toJson() provides the serialized output for transport or persistence. Important implementation notes for reimplementation or adaptation: validate the Python dict (not a JSON string) against the schema (e.g., jsonschema.validate(instance=self.__dict__, schema=User.schema) or jsonschema.Draft7Validator(...).validate(...)); keep schema as a dict constant or external file, consider adding validation hooks (classmethods like from_dict/from_json), type hints or a dataclass for clearer typing, and explicit error handling to convert jsonschema exceptions into application errors; optionally enforce additionalProperties=false or extend the schema for nested types, versions (Draft), default values, and custom validators.", "This module implements a small, pure-text transformer that maps an input string to a compact hybrid representation useful for puzzles, obfuscation, or stylized encoding: vowels are preserved as uppercase letters while consonants are replaced with their Morse-code patterns, and all non-alphabetic characters are dropped. Core components are a vowel predicate (a lowercase vowel set checked case-insensitively) and a lookup table mapping uppercase consonant letters to Morse strings; the main function iterates the input characters, skips anything that is not .isalpha(), converts letters case-insensitively, appends the uppercase letter if it is a vowel, or appends the corresponding Morse pattern if it is a consonant. The API is a single function that takes a Python string and returns a single concatenated string (no separators between tokens), runs in O(n) time and constant extra memory beyond output size, and is side-effect-free. To reimplement or adapt: provide a vowel set and a consonant->Morse mapping, decide how to handle non-ASCII letters or accented characters (current behavior drops them), choose whether to preserve word boundaries or insert delimiters between letters or Morse tokens, and optionally expose options to keep punctuation, emit spaces as separators, or raise errors for unmapped characters."]}