{"x": ["import pandas as pd\nfrom pandas.io.json import json_normalize\n\n# Sample JSON object\njson_data = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"address\": {\n        \"street\": \"123 Main St\",\n        \"city\": \"New York\",\n        \"state\": \"NY\"\n    },\n    \"hobbies\": [\"reading\", \"sports\"],\n    \"friends\": [\n        {\n            \"name\": \"Jane\",\n            \"age\": 28\n        },\n        {\n            \"name\": \"Mike\",\n            \"age\": 32\n        }\n    ]\n}\n\n# Convert JSON object to Pandas DataFrame\ndf = json_normalize(json_data)\n\n# Print the DataFrame\nprint(df)", "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list using the bubble sort algorithm.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)  # Number of elements in the list\n    sorted_arr = list(arr)  # Create a copy of the original list\n    \n    # Iterate through the list until it is sorted\n    for i in range(n):\n        swapped = False  # Flag variable to optimize the sorting process\n        \n        # Iterate through the list from index 0 to n-i-1\n        # (The last i elements are already in place)\n        for j in range(0, n-i-1):\n            \n            # Compare adjacent elements and swap them if they are in the wrong order\n            if sorted_arr[j] > sorted_arr[j+1]:\n                sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j]\n                swapped = True  # Set the flag variable to True\n                \n        # If no swaps were made in a pass, the list is already sorted\n        if not swapped:\n            break\n    \n    return sorted_arr\n\n# Test the bubble_sort function with the given list\noriginal_list = [36, 71, 16, 21, 73, 5, 99, 42, 12, 67, 24, 88]\nprint(\"Original list:\", original_list)\n\nsorted_list = bubble_sort(original_list)\nprint(\"Sorted list:\", sorted_list)", "def calculate_final_price(original_price, tax_percentage, concession_percentage):\n    # Calculate service tax amount\n    tax_amount = original_price * (tax_percentage / 100.0)\n    \n    # Calculate the price after adding tax\n    price_after_tax = original_price + tax_amount\n    \n    # Calculate the concession amount\n    concession_amount = price_after_tax * (concession_percentage / 100.0)\n    \n    # Deduct the concession from the price\n    final_price = price_after_tax - concession_amount\n    \n    # Return the final price\n    return final_price", "def partition(array, low, high, indexes):\n    i = low - 1\n    pivot = array[indexes[high]]\n\n    for j in range(low, high):\n        if array[indexes[j]] <= pivot:\n            i += 1\n            indexes[i], indexes[j] = indexes[j], indexes[i]\n\n    indexes[i+1], indexes[high] = indexes[high], indexes[i+1]\n    return (i+1)\n\ndef quickSort(array, low, high, indexes):\n    if low < high:\n        pi = partition(array, low, high, indexes)\n        quickSort(array, low, pi-1, indexes)\n        quickSort(array, pi+1, high, indexes)\n\ndef sortEvenNumbers(array):\n    try:\n        indexes = [i for i, num in enumerate(array) if num % 2 == 0]\n        quickSort(array, 0, len(indexes)-1, indexes)\n\n        output = array.copy()\n        for i, index in enumerate(indexes):\n            output[index] = array[indexes[i]]\n\n        print(\"Sorted array is: \", output)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\ninputArray = [12, -6, 47, 18, 0, -3]\nsortEvenNumbers(inputArray)", "import logging\n\nclass LoggingConfigurator:\n    def __init__(self, config):\n        self.config = config\n        self.handlers = {}\n\n    def add_handler(self, handler_name, handler_settings):\n        self.handlers[handler_name] = handler_settings\n\n    def set_level(self, handler_name, level):\n        if handler_name in self.handlers:\n            self.handlers[handler_name]['level'] = level\n        else:\n            raise ValueError(f\"Handler '{handler_name}' does not exist.\")\n\n    def configure_logging(self):\n        for handler_name, settings in self.handlers.items():\n            handler_class = settings.get('class')\n            level = settings.get('level')\n            formatter = settings.get('formatter')\n\n            if handler_class == 'logging.StreamHandler':\n                handler = logging.StreamHandler()\n            elif handler_class == 'logging.FileHandler':\n                handler = logging.FileHandler('app.log')\n            else:\n                raise ValueError(f\"Unsupported handler class: {handler_class}\")\n\n            handler.setLevel(getattr(logging, level))\n            handler.setFormatter(logging.Formatter(formatter))\n            logging.getLogger().addHandler(handler)\n\n# Example usage\nconfig = {\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'class': 'logging.StreamHandler',\n            'formatter': 'console'\n        },\n        'null': {\n            'level': 'DEBUG',\n            'class': 'logging.NullHandler'\n        }\n    }\n}\n\nlogger_configurator = LoggingConfigurator(config)\nlogger_configurator.add_handler('console', config['handlers']['console'])\nlogger_configurator.add_handler('null', config['handlers']['null'])\nlogger_configurator.set_level('console', 'INFO')\nlogger_configurator.configure_logging()\n\n# Now the logging system is configured based on the provided settings\n# Logs will be written to console with INFO level and /dev/null with DEBUG level", "num_list = []\nnum = 100\n\nwhile num >= 0:\n    if num % 4 == 0 and num % 3 != 0 and num % 7 != 0:\n        num_list.append(num)\n    num -= 1\n\nnum_list.sort(reverse=True)\nsum_of_nums = sum(num_list)\n\nprint(num_list)\nprint(sum_of_nums)", "class StringManipulator:\n    def __init__(self, string):\n        self.string = string\n\n    def capitalize_first_letter(self):\n        self.string = self.string.capitalize()\n\n    def reverse_capitalization(self):\n        reversed_string = ''\n        for char in self.string:\n            if char.isalpha():\n                if char.isupper():\n                    reversed_string += char.lower()\n                else:\n                    reversed_string += char.upper()\n            else:\n                reversed_string += char\n        self.string = reversed_string\n\n    def count_character(self, char):\n        return self.string.count(char)", "class Node: \n    def __init__(self, key): \n        self.data = key  \n        self.left = None\n        self.right = None\n\ndef compute_tree_height(node): \n    if node is None: \n        return -1;   \n    else :\n        # Compute the depth of each subtree and use recursion\n        left_depth = compute_tree_height(node.left) \n        right_depth = compute_tree_height(node.right) \n   \n        # Use the larger one \n        if (left_depth > right_depth): \n            return left_depth+1\n        else: \n            return right_depth+1\n  \n# Driver code to test above\nroot = Node(1) \nroot.left = Node(2) \nroot.right = Node(3) \nroot.left.left = Node(4) \nroot.left.right = Node(5) \n  \nprint (\"Height of the binary tree is: %d\" %(compute_tree_height(root))) ", "import requests\nfrom bs4 import BeautifulSoup\n\nURL = \"https://docs.python.org/3/tutorial/\"\n\nr = requests.get(URL)\n\nsoup = BeautifulSoup(r.content, 'html5lib') \n\nheadings = soup.find_all(['h1', 'h2','h3'])\n\nfor heading in headings:\n    print(heading.text.strip())", "import random\n\n# Generate a random integer between 3 and 10\nn = random.randint(3, 10)\n\n# Create a list with elements 0-9 repeated n times\nlst = [i for i in range(10) for _ in range(n)]\n\nprint(lst)"], "preds": ["This code demonstrates the use of pandas json_normalize function to flatten a nested JSON object into a tabular DataFrame structure suitable for analysis or data manipulation. The primary use case is transforming hierarchical or semi-structured JSON data, which may contain nested dictionaries and arrays, into a flat two-dimensional table where nested keys are represented as dot-notation column names. The input is a Python dictionary representing JSON data with multiple levels of nesting, including a nested address object, a simple list of hobbies, and a list of friend objects with their own attributes. The json_normalize function processes this structure by flattening nested dictionaries into columns like \"address.street\", \"address.city\", and \"address.state\", while handling arrays differently depending on their content; simple arrays like hobbies are typically stored as-is in a single cell, whereas arrays of objects like friends may require additional parameters or separate normalization calls to fully flatten. The output is a pandas DataFrame with one row containing all the flattened data, where each nested field becomes a separate column with hierarchical keys joined by periods. To implement or adapt this in practice, engineers should recognize that json_normalize is ideal for APIs or data sources returning nested JSON responses, and they may need to use parameters like record_path, meta, and sep to control how deeply nested structures and repeated records are handled, especially when dealing with arrays of objects that should be expanded into multiple rows rather than stored in single cells.", "This code implements the bubble sort algorithm, a comparison-based sorting technique that repeatedly steps through a list, compares adjacent elements, and swaps them if they are in the wrong order. The function takes a single input, a list of comparable elements (typically numbers), and returns a new sorted list in ascending order without modifying the original input. The implementation uses a two-loop structure: an outer loop that runs up to n iterations (where n is the list length) and an inner loop that performs pairwise comparisons and swaps on progressively smaller unsorted portions of the list, since the largest elements \"bubble up\" to the end with each pass. A key optimization is the use of a swapped flag that tracks whether any swaps occurred during a pass; if no swaps are made, the list is already sorted and the algorithm terminates early, improving best-case performance to O(n) for already-sorted data. The worst-case and average time complexity remain O(n\u00b2), making this suitable only for small datasets or educational purposes. The space complexity is O(n) due to creating a copy of the input list. To adapt this code, an engineer could modify the comparison operator to sort in descending order, make it sort in-place by removing the list copy operation, add a custom comparator function parameter for complex objects, or replace it with more efficient algorithms like quicksort or mergesort for production use with larger datasets.", "This function calculates the final price of a product or service after applying a sequential two-step pricing adjustment: first adding a tax to the original price, then applying a percentage-based concession or discount to the tax-inclusive amount. The function accepts three numeric inputs: the original price before any adjustments, a tax percentage to be applied, and a concession percentage representing a discount. The core logic performs percentage-based calculations where the tax is computed as a percentage of the original price and added to it, then the concession is computed as a percentage of the tax-inclusive price and subtracted from it. The function returns a single numeric value representing the final amount to be paid. This implementation assumes that the concession applies to the already-taxed price rather than the original price, which is a critical specification for correct replication. The use case is typical for pricing systems in retail, e-commerce, or service industries where tax must be applied before promotional discounts, or where concessions are calculated on the gross amount including statutory charges. When reimplementing or adapting this code, ensure that the order of operations\u2014tax first, then concession\u2014is preserved, and handle input validation for negative values or unrealistic percentages as needed for production environments.", "This code implements a specialized sorting algorithm that selectively sorts only the even numbers within an array while leaving odd numbers in their original positions. The solution uses an indirect quicksort approach where an index array tracks the positions of even numbers rather than moving elements during the sort operation. The main function sortEvenNumbers first identifies all even-number positions in the input array by filtering indices where the element modulo 2 equals zero, then applies a standard quicksort algorithm that operates on this index array rather than the original data. The partition and quickSort functions implement the classic quicksort logic but manipulate the indexes array while using the original array values for comparison decisions, ensuring that only the relative ordering information of even numbers is captured. After sorting the index array, the code creates a copy of the original array and remaps the even numbers according to their new sorted order by placing the element at indexes[i] into position indexes[i] in the output. The implementation includes basic error handling to catch exceptions during execution. The intended use case is scenarios where partial sorting is required to maintain the spatial relationship of certain elements (odd numbers) while reordering others (even numbers) in place, such as when processing data streams with categorical constraints or implementing stable sorting variants. To reimplement, an engineer should maintain three key components: an index filter to identify target elements, an indirect sorting mechanism that sorts indices based on referenced values, and a remapping step that applies the sorted index permutation back to produce the final output array.", "The LoggingConfigurator class provides a programmatic interface for dynamically configuring Python's logging system based on structured configuration data. Its primary purpose is to accept handler definitions (console, file, or null handlers), allow runtime modification of logging levels, and apply these configurations to the root logger. The class is initialized with a config dictionary and maintains an internal handlers dictionary that maps handler names to their settings, which include handler class type, logging level, and formatter string. Key methods include add_handler for registering new handlers with their settings, set_level for updating a handler's logging level with validation, and configure_logging which iterates through all registered handlers, instantiates the appropriate handler objects (StreamHandler or FileHandler with hardcoded filename 'app.log'), sets their levels using string-to-constant conversion via getattr, applies formatters, and attaches them to the root logger. The intended use case is environments requiring flexible, code-driven logging setup where configurations may come from external sources like config files or databases. To implement or adapt this, an engineer should note that the handler class mapping is limited (only StreamHandler and FileHandler are supported, with FileHandler using a fixed filename), formatter strings are applied directly without predefined formatter objects, and the code operates on the root logger rather than named loggers. For production use, this would need enhancement to support configurable file paths, additional handler types, formatter object definitions, and named logger hierarchies rather than just root logger configuration.", "This code generates a filtered list of integers from a specified range and computes their sum, specifically targeting numbers divisible by 4 but not divisible by 3 or 7. The implementation uses a countdown loop starting from 100 down to 0 (inclusive), applying a compound modulo condition to select only numbers that satisfy all three criteria simultaneously: divisible by 4, not divisible by 3, and not divisible by 7. Selected numbers are accumulated into a list, which is then sorted in descending order before calculating the sum of all elements. The outputs are the sorted list and the total sum, both printed to the console. To reimplement or adapt this, the key parameters are the starting value (100), the countdown direction, and the three divisibility rules (mod 4 equals 0, mod 3 not equals 0, mod 7 not equals 0). The sorting step is somewhat redundant since the countdown naturally produces descending order if numbers are appended sequentially, but it ensures the output format regardless of insertion order. This pattern is useful for number theory problems, filtering sequences based on divisibility properties, or generating test data with specific mathematical constraints.", "The StringManipulator class is a stateful string processing utility that encapsulates a mutable string and provides three manipulation operations. Upon instantiation, it accepts a string argument that becomes the internal state. The class offers three methods: capitalize_first_letter applies Python's built-in capitalize method to transform the first character to uppercase and all remaining characters to lowercase, modifying the internal string in place; reverse_capitalization iterates through each character and inverts the case of alphabetic characters (uppercase to lowercase and vice versa) while preserving non-alphabetic characters unchanged, also mutating the internal state; and count_character takes a character argument and returns the count of occurrences of that character in the current internal string without modifying state. The key design characteristic is that the first two methods permanently alter the stored string, so sequential calls will operate on the modified version, and users need to be aware that the object maintains mutable state rather than returning new string instances. This design pattern is useful when multiple transformations need to be applied to a string in sequence while maintaining a single reference to the evolving result, though it differs from typical immutable string handling in Python.", "This code implements a binary tree height calculation algorithm using a recursive depth-first traversal approach. The Node class defines a simple binary tree node structure with a data field and left and right child pointers. The compute_tree_height function recursively computes the height of a binary tree by traversing to leaf nodes and returning -1 for null nodes, then propagating upward by taking the maximum of the left and right subtree heights and adding 1 at each level. The height is defined as the number of edges in the longest path from root to leaf, which is why null nodes return -1 (so a single-node tree returns 0). The function accepts a tree node as input and returns an integer representing the tree height. The driver code demonstrates usage by constructing a sample binary tree with root value 1, left child 2 with its own children 4 and 5, and right child 3, then prints the computed height which should be 2. To adapt this code, instantiate Node objects to build the desired tree structure and call compute_tree_height with the root node; the algorithm has O(n) time complexity as it visits each node once and O(h) space complexity due to recursion stack depth where h is the tree height.", "This code implements a web scraping solution to extract and display hierarchical heading text from the Python tutorial documentation website. The program uses the requests library to perform an HTTP GET request to retrieve the HTML content of a specified URL, then employs BeautifulSoup with the html5lib parser to parse the HTML document into a navigable tree structure. The core functionality searches for all heading elements at levels h1, h2, and h3 within the parsed document, iterates through the collected heading elements, and prints each heading's text content after stripping leading and trailing whitespace. The intended use case is to quickly extract the outline or table of contents structure from a web page by isolating heading elements, which is useful for content analysis, documentation indexing, or generating summaries of web-based documentation. To adapt this code, an engineer would modify the URL constant to target different web pages, potentially adjust the list of heading tags to include or exclude specific levels, add error handling for network failures or parsing issues, implement output formatting or storage mechanisms for the extracted headings, and consider rate limiting or robots.txt compliance for production scraping applications.", "This code generates a list containing the integers 0 through 9, where each integer appears a random number of times determined by a single random multiplier n (between 3 and 10 inclusive). The core behavior is to first select a uniform random integer n, then construct a list through nested list comprehension where the outer loop iterates over the range 0-9 and the inner loop repeats each integer exactly n times before moving to the next. The result is a deterministic pattern where all digits have equal repetition counts within a single execution, but the repetition count varies between executions. The output is a flat list of length 10*n (ranging from 30 to 100 elements) printed to standard output, with values appearing in ascending order grouped by repetition (e.g., [0,0,0,1,1,1,2,2,2,...,9,9,9] if n=3). To reimplement or adapt this, the key specifications are: select a random repetition factor once, apply it uniformly to all elements in a defined range (0-9), and maintain ordered grouping of repeated values."]}