{"x": ["import jsonschema\nimport json\n\nclass User:\n    schema = {\n        \"type\" : \"object\",\n        \"properties\" : {\n            \"firstName\" : {\n                \"type\" : \"string\"\n            },\n            \"lastName\" : {\n                \"type\" : \"string\"\n            },\n            \"age\" : {\n                \"description\" : \"Age in years\",\n                \"type\" : \"integer\",\n                \"minimum\" : 0\n            }\n        },\n        \"required\" : [\"firstName\", \"lastName\"]\n    }\n    \n    def __init__(self, firstName, lastName, age=None):\n        self.firstName = firstName\n        self.lastName = lastName\n        self.age = age\n        # validate the input JSON against the schema\n        jsonschema.validate(self.toJson(), User.schema)\n    \n    def toJson(self):\n        # returns a json representation of the user object.\n        return json.dumps(self.__dict__)", "def is_vowel(ch):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return ch.lower() in vowels\n\nmorse_code = {\n    'B': '-...',\n    'C': '-.-.',\n    'D': '-..',\n    'F': '..-.',\n    'G': '--.',\n    'H': '....',\n    'J': '.---',\n    'K': '-.-',\n    'L': '.-..',\n    'M': '--',\n    'N': '-.',\n    'P': '.--.',\n    'Q': '--.-',\n    'R': '.-.',\n    'S': '...',\n    'T': '-',\n    'V': '...-',\n    'W': '.--',\n    'X': '-..-',\n    'Y': '-.--',\n    'Z': '--..'\n}\n\ndef convert_string(s):\n    result = ''\n    for ch in s:\n        if not ch.isalpha():\n            continue\n        if is_vowel(ch):\n            result += ch.upper()\n        else:\n            result += morse_code[ch.upper()]\n    return result"], "preds": ["This code implements a validated User data model class using JSON Schema for runtime validation of user data. The User class encapsulates three attributes: firstName and lastName as required string fields, and age as an optional non-negative integer field. The class defines a JSON Schema specification as a class-level attribute that describes the expected structure and constraints of valid user data, including type requirements, minimum value constraints for age, and mandatory fields. Upon instantiation, the constructor accepts firstName and lastName as required parameters and age as an optional parameter with a default of None, then immediately validates the created object by converting it to JSON format via the toJson method and validating against the schema using the jsonschema library's validate function, which will raise a validation exception if the data does not conform to the schema rules. The toJson method serializes the object's instance dictionary to a JSON string representation. The intended use case is to ensure data integrity at object creation time by enforcing schema constraints declaratively, preventing invalid User objects from being instantiated. To adapt this pattern, engineers should define appropriate JSON Schema specifications for their domain objects, call validation at appropriate lifecycle points, and handle potential ValidationError exceptions raised by jsonschema when invalid data is provided. Note that the current implementation has a subtle issue: toJson returns a JSON string but jsonschema.validate expects a dictionary, so a proper implementation should pass self.__dict__ directly to validate or parse the JSON string back to a dictionary before validation.", "This code implements a string transformation function that converts alphabetic characters into a hybrid format where vowels are uppercased and consonants are replaced with their Morse code equivalents. The main function convert_string takes a string as input and iterates through each character, skipping any non-alphabetic characters entirely. For each alphabetic character, it uses the is_vowel helper function to determine if the character is a vowel (a, e, i, o, u, case-insensitive); if so, it appends the uppercase version of the vowel to the result string. If the character is a consonant, it looks up the uppercase version of the character in a predefined morse_code dictionary and appends the corresponding Morse code pattern (composed of dots and dashes) to the result. The morse_code dictionary contains mappings for all English consonants from B to Z, notably excluding vowels. The output is a single concatenated string with no delimiters between characters, consisting of uppercase vowels and Morse code sequences for consonants. To reimplement or adapt this, an engineer should maintain the vowel detection logic, ensure the Morse code lookup dictionary includes all necessary consonants, handle case-insensitivity appropriately, and decide whether non-alphabetic characters should be ignored, preserved, or handled differently based on the specific use case."]}