{"x": ["import pandas as pd\nfrom pandas.io.json import json_normalize\n\n# Sample JSON object\njson_data = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"address\": {\n        \"street\": \"123 Main St\",\n        \"city\": \"New York\",\n        \"state\": \"NY\"\n    },\n    \"hobbies\": [\"reading\", \"sports\"],\n    \"friends\": [\n        {\n            \"name\": \"Jane\",\n            \"age\": 28\n        },\n        {\n            \"name\": \"Mike\",\n            \"age\": 32\n        }\n    ]\n}\n\n# Convert JSON object to Pandas DataFrame\ndf = json_normalize(json_data)\n\n# Print the DataFrame\nprint(df)", "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list using the bubble sort algorithm.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)  # Number of elements in the list\n    sorted_arr = list(arr)  # Create a copy of the original list\n    \n    # Iterate through the list until it is sorted\n    for i in range(n):\n        swapped = False  # Flag variable to optimize the sorting process\n        \n        # Iterate through the list from index 0 to n-i-1\n        # (The last i elements are already in place)\n        for j in range(0, n-i-1):\n            \n            # Compare adjacent elements and swap them if they are in the wrong order\n            if sorted_arr[j] > sorted_arr[j+1]:\n                sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j]\n                swapped = True  # Set the flag variable to True\n                \n        # If no swaps were made in a pass, the list is already sorted\n        if not swapped:\n            break\n    \n    return sorted_arr\n\n# Test the bubble_sort function with the given list\noriginal_list = [36, 71, 16, 21, 73, 5, 99, 42, 12, 67, 24, 88]\nprint(\"Original list:\", original_list)\n\nsorted_list = bubble_sort(original_list)\nprint(\"Sorted list:\", sorted_list)", "def calculate_final_price(original_price, tax_percentage, concession_percentage):\n    # Calculate service tax amount\n    tax_amount = original_price * (tax_percentage / 100.0)\n    \n    # Calculate the price after adding tax\n    price_after_tax = original_price + tax_amount\n    \n    # Calculate the concession amount\n    concession_amount = price_after_tax * (concession_percentage / 100.0)\n    \n    # Deduct the concession from the price\n    final_price = price_after_tax - concession_amount\n    \n    # Return the final price\n    return final_price", "def partition(array, low, high, indexes):\n    i = low - 1\n    pivot = array[indexes[high]]\n\n    for j in range(low, high):\n        if array[indexes[j]] <= pivot:\n            i += 1\n            indexes[i], indexes[j] = indexes[j], indexes[i]\n\n    indexes[i+1], indexes[high] = indexes[high], indexes[i+1]\n    return (i+1)\n\ndef quickSort(array, low, high, indexes):\n    if low < high:\n        pi = partition(array, low, high, indexes)\n        quickSort(array, low, pi-1, indexes)\n        quickSort(array, pi+1, high, indexes)\n\ndef sortEvenNumbers(array):\n    try:\n        indexes = [i for i, num in enumerate(array) if num % 2 == 0]\n        quickSort(array, 0, len(indexes)-1, indexes)\n\n        output = array.copy()\n        for i, index in enumerate(indexes):\n            output[index] = array[indexes[i]]\n\n        print(\"Sorted array is: \", output)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\ninputArray = [12, -6, 47, 18, 0, -3]\nsortEvenNumbers(inputArray)", "import logging\n\nclass LoggingConfigurator:\n    def __init__(self, config):\n        self.config = config\n        self.handlers = {}\n\n    def add_handler(self, handler_name, handler_settings):\n        self.handlers[handler_name] = handler_settings\n\n    def set_level(self, handler_name, level):\n        if handler_name in self.handlers:\n            self.handlers[handler_name]['level'] = level\n        else:\n            raise ValueError(f\"Handler '{handler_name}' does not exist.\")\n\n    def configure_logging(self):\n        for handler_name, settings in self.handlers.items():\n            handler_class = settings.get('class')\n            level = settings.get('level')\n            formatter = settings.get('formatter')\n\n            if handler_class == 'logging.StreamHandler':\n                handler = logging.StreamHandler()\n            elif handler_class == 'logging.FileHandler':\n                handler = logging.FileHandler('app.log')\n            else:\n                raise ValueError(f\"Unsupported handler class: {handler_class}\")\n\n            handler.setLevel(getattr(logging, level))\n            handler.setFormatter(logging.Formatter(formatter))\n            logging.getLogger().addHandler(handler)\n\n# Example usage\nconfig = {\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'class': 'logging.StreamHandler',\n            'formatter': 'console'\n        },\n        'null': {\n            'level': 'DEBUG',\n            'class': 'logging.NullHandler'\n        }\n    }\n}\n\nlogger_configurator = LoggingConfigurator(config)\nlogger_configurator.add_handler('console', config['handlers']['console'])\nlogger_configurator.add_handler('null', config['handlers']['null'])\nlogger_configurator.set_level('console', 'INFO')\nlogger_configurator.configure_logging()\n\n# Now the logging system is configured based on the provided settings\n# Logs will be written to console with INFO level and /dev/null with DEBUG level", "num_list = []\nnum = 100\n\nwhile num >= 0:\n    if num % 4 == 0 and num % 3 != 0 and num % 7 != 0:\n        num_list.append(num)\n    num -= 1\n\nnum_list.sort(reverse=True)\nsum_of_nums = sum(num_list)\n\nprint(num_list)\nprint(sum_of_nums)", "class StringManipulator:\n    def __init__(self, string):\n        self.string = string\n\n    def capitalize_first_letter(self):\n        self.string = self.string.capitalize()\n\n    def reverse_capitalization(self):\n        reversed_string = ''\n        for char in self.string:\n            if char.isalpha():\n                if char.isupper():\n                    reversed_string += char.lower()\n                else:\n                    reversed_string += char.upper()\n            else:\n                reversed_string += char\n        self.string = reversed_string\n\n    def count_character(self, char):\n        return self.string.count(char)", "class Node: \n    def __init__(self, key): \n        self.data = key  \n        self.left = None\n        self.right = None\n\ndef compute_tree_height(node): \n    if node is None: \n        return -1;   \n    else :\n        # Compute the depth of each subtree and use recursion\n        left_depth = compute_tree_height(node.left) \n        right_depth = compute_tree_height(node.right) \n   \n        # Use the larger one \n        if (left_depth > right_depth): \n            return left_depth+1\n        else: \n            return right_depth+1\n  \n# Driver code to test above\nroot = Node(1) \nroot.left = Node(2) \nroot.right = Node(3) \nroot.left.left = Node(4) \nroot.left.right = Node(5) \n  \nprint (\"Height of the binary tree is: %d\" %(compute_tree_height(root))) ", "import requests\nfrom bs4 import BeautifulSoup\n\nURL = \"https://docs.python.org/3/tutorial/\"\n\nr = requests.get(URL)\n\nsoup = BeautifulSoup(r.content, 'html5lib') \n\nheadings = soup.find_all(['h1', 'h2','h3'])\n\nfor heading in headings:\n    print(heading.text.strip())", "import random\n\n# Generate a random integer between 3 and 10\nn = random.randint(3, 10)\n\n# Create a list with elements 0-9 repeated n times\nlst = [i for i in range(10) for _ in range(n)]\n\nprint(lst)"], "preds": ["\n\nThis code is designed to convert a nested JSON object into a structured Pandas DataFrame for easier data manipulation and analysis. The intended use case is to take complex JSON data with nested objects and arrays, and transform it into a tabular format that can be easily queried and processed. The code assumes an input JSON object with arbitrary nesting, including objects and arrays, and produces a Pandas DataFrame with columns corresponding to the top-level keys and values, as well as flattened versions of nested objects and arrays. The output is a Pandas DataFrame that can be further manipulated using various Pandas functions, such as filtering, grouping, and merging. To implement this solution, one would need to have Pandas installed and import the necessary libraries, including `pandas` and `pandas.io.json`. The input JSON object can be any nested structure, and the code will automatically flatten it into a DataFrame.", "\n\nThis code implements a bubble sort algorithm, a simple sorting technique used to arrange elements of an input list in ascending order. The code takes a list of elements as input and returns the sorted list. The algorithm iteratively compares adjacent elements in the list, swapping them if they are in the wrong order, until no more swaps are needed, indicating the list is sorted. The code iterates through the list multiple times, with each pass reducing the number of elements to be compared, until the entire list is sorted. The input is a list of elements of any data type that can be compared, and the output is the sorted list. The code is designed to be efficient for small to medium-sized lists, but may not be suitable for large datasets due to its O(n^2) time complexity. To implement this code, one would need to define a list of elements, call the bubble_sort function with the list as an argument, and store the returned sorted list.", "\n\nThis code implements a pricing calculation function that determines the final price of a product or service after applying tax and concession. The function takes three inputs: the original price, tax percentage, and concession percentage. It calculates the tax amount, adds it to the original price to obtain the price after tax, then calculates the concession amount as a percentage of the price after tax. The concession amount is then deducted from the price after tax to obtain the final price, which is returned as the output. This function is designed to be used in scenarios where a product or service is subject to both tax and concession, and is intended for use in a business or e-commerce application where pricing calculations need to be performed dynamically. The function's inputs and outputs can be easily adapted to accommodate different tax and concession rates, making it a flexible tool for pricing calculations.", "\n\nThis code implements a modified quicksort algorithm to sort an array of integers in ascending order, but only for even numbers. The high-level purpose is to partition the input array into two parts: even numbers and odd numbers, and then sort the even numbers in place using the quicksort algorithm. The code takes an input array of integers and outputs the sorted array of even numbers. The technical specifications include the use of an auxiliary array of indexes to track the positions of even numbers in the original array, and the implementation of the quicksort algorithm to sort the even numbers. The code is designed to handle arrays of integers and can be adapted to sort even numbers from any type of array. The implementation involves recursively partitioning the array of even numbers, swapping elements in the original array based on the sorted indexes, and returning the sorted array of even numbers.", "\n\nThis code is a logging configurator class designed to dynamically configure a logging system based on a provided configuration dictionary. Its primary purpose is to allow for flexible and modular logging setup, enabling the creation of multiple log handlers with distinct settings, such as log levels, output destinations, and formatting. The configurator takes a configuration dictionary as input, which defines the log handlers and their settings, and uses this information to create and configure the corresponding log handlers. The configurator supports various types of handlers, including stream handlers for console output and file handlers for writing to log files, as well as null handlers for discarding log messages. The class can be used to configure logging for a logging system, allowing for easy switching between different logging configurations. To implement this solution, a configuration dictionary should be created to define the log handlers and their settings, and then an instance of the LoggingConfigurator class should be created, passed the configuration dictionary, and used to configure the logging system.", "\n\nThis code is designed to generate a list of numbers that meet specific divisibility criteria and then calculate the sum of those numbers. The intended use case is to identify and accumulate numbers within a given range (in this case, from 100 down to 0) that are divisible by 4 but not by 3 or 7. The code iterates through the range in descending order, checking each number for the specified divisibility conditions, and appends it to a list if it meets the criteria. The list is then sorted in descending order and the sum of its elements is calculated. The output consists of the sorted list of numbers and their cumulative sum. To implement or adapt this solution, an engineer would need to define the range, specify the divisibility conditions, and adjust the sorting and summing logic as needed for their particular use case.", "\n\nThis code defines a class called StringManipulator, which is designed to manipulate and analyze strings. The class takes a string as input in its constructor and provides three methods: capitalize_first_letter, reverse_capitalization, and count_character. The capitalize_first_letter method capitalizes the first letter of the input string, while the reverse_capitalization method swaps the case of alphabetic characters in the string, leaving non-alphabetic characters unchanged. The count_character method returns the number of occurrences of a specified character in the string. The class is intended for use in scenarios where string manipulation and analysis is required, such as data preprocessing, text processing, or validation. It can be implemented in practice by creating an instance of the StringManipulator class, passing a string to its constructor, and calling the desired methods to perform the necessary operations.", "\n\nThis code implements a binary tree data structure and a function to compute the height of the tree. The binary tree is represented as a linked list of nodes, where each node contains a key value and references to its left and right child nodes. The compute_tree_height function recursively traverses the tree, calculating the depth of each subtree and returning the maximum depth, which represents the height of the tree. The code is designed to be used in scenarios where a binary tree needs to be analyzed or traversed, such as in algorithms for sorting, searching, or data compression. The implementation involves creating a binary tree with a specified root node and its child nodes, and then calling the compute_tree_height function to calculate the height of the tree. The output is the height of the binary tree, which can be used for further analysis or processing.", "\n\nThis code is designed to extract and print the text content of all h1, h2, and h3 headings from a given webpage, specifically the Python 3 tutorial documentation. It utilizes the requests library to fetch the webpage content and the BeautifulSoup library to parse the HTML content. The code sends a GET request to the specified URL, parses the HTML content using the html5lib parser, and then finds all occurrences of h1, h2, and h3 tags. The text content of these headings is then stripped of any leading or trailing whitespace and printed to the console. This code can be adapted for use cases where web scraping is necessary to extract structured data from a webpage, and can be modified to target specific websites or HTML elements by adjusting the URL and the find_all method parameters.", "\n\nThis code generates a list of integers from 0 to 9 repeated a specified number of times, determined by a randomly selected integer between 3 and 10. The code uses the random module to generate a random integer, which is then used as a multiplier to create a list of repeated integers. The output is a list of 10 integers repeated a random number of times between 3 and 10. The code can be adapted for use in scenarios where a large dataset needs to be generated with a variable number of repetitions, such as in data simulation or testing environments. To implement this code, an engineer would need to import the random module, generate a random integer, and use a list comprehension to create the repeated list of integers."]}