{"x": ["import jsonschema\nimport json\n\nclass User:\n    schema = {\n        \"type\" : \"object\",\n        \"properties\" : {\n            \"firstName\" : {\n                \"type\" : \"string\"\n            },\n            \"lastName\" : {\n                \"type\" : \"string\"\n            },\n            \"age\" : {\n                \"description\" : \"Age in years\",\n                \"type\" : \"integer\",\n                \"minimum\" : 0\n            }\n        },\n        \"required\" : [\"firstName\", \"lastName\"]\n    }\n    \n    def __init__(self, firstName, lastName, age=None):\n        self.firstName = firstName\n        self.lastName = lastName\n        self.age = age\n        # validate the input JSON against the schema\n        jsonschema.validate(self.toJson(), User.schema)\n    \n    def toJson(self):\n        # returns a json representation of the user object.\n        return json.dumps(self.__dict__)", "def is_vowel(ch):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return ch.lower() in vowels\n\nmorse_code = {\n    'B': '-...',\n    'C': '-.-.',\n    'D': '-..',\n    'F': '..-.',\n    'G': '--.',\n    'H': '....',\n    'J': '.---',\n    'K': '-.-',\n    'L': '.-..',\n    'M': '--',\n    'N': '-.',\n    'P': '.--.',\n    'Q': '--.-',\n    'R': '.-.',\n    'S': '...',\n    'T': '-',\n    'V': '...-',\n    'W': '.--',\n    'X': '-..-',\n    'Y': '-.--',\n    'Z': '--..'\n}\n\ndef convert_string(s):\n    result = ''\n    for ch in s:\n        if not ch.isalpha():\n            continue\n        if is_vowel(ch):\n            result += ch.upper()\n        else:\n            result += morse_code[ch.upper()]\n    return result"], "preds": ["This code implements a minimal Python data model for a \"User\" with built-in JSON Schema validation: a class-level JSON Schema dict defines three properties (firstName:string, lastName:string, age:integer \u2265 0) with firstName and lastName required; the constructor accepts firstName, lastName and optional age, assigns them to instance attributes, and validates the instance against the schema using the jsonschema library; toJson() serializes the instance dictionary to a JSON string via json.dumps. Intended use is runtime input validation and serialization for APIs, storage, or inter-process messages: instantiate User(...) to validate data immediately and call toJson() to get a JSON payload; invalid inputs raise jsonschema.ValidationError. Key implementation notes for reimplementation or adaptation: keep the schema as a class-level dict so it can be extended or overridden, perform validation on a Python dict (pass self.__dict__ to jsonschema.validate rather than a JSON string) because jsonschema.validate expects a mapping, optionally add \"additionalProperties\": False to forbid extra fields, return either a dict or string depending on consumers, and surface validation errors cleanly (wrap or rethrow) or use a dataclass/pydantic alternative for richer typing, defaults, and better error messages; dependency: jsonschema and the standard json module.", "This module provides a small string-conversion utility whose purpose is to transform an input string into a compact representation where alphabetic vowels are preserved as uppercase letters and alphabetic consonants are replaced by predefined Morse-code strings; all non-alphabetic characters are dropped. Implemented as convert_string(s: str) -> str with a helper is_vowel(ch) that tests membership in the vowel set {a,e,i,o,u} (case-insensitive), the function iterates the input, skips any non-alpha characters, appends ch.upper() for vowels and appends morse_code[ch.upper()] for consonants, where morse_code is a dict mapping the 21 English consonant letters (B,C,D,F,...,Z) to their dot/dash sequences; the routine is linear time O(n) and returns the concatenated sequence with no separators between Morse tokens. Practical considerations when reimplementing: ensure case-insensitive handling and that the morse map covers every expected consonant or add a safe lookup/fallback to avoid KeyError for unexpected alphabetic characters (e.g., locale-specific letters); consider using a list and join for better performance when building the output, add delimiters between Morse symbols if consumers need token boundaries, and extend the mapping to digits/punctuation or preserve original non-alpha characters if required by your use case."]}