{"x": ["import pandas as pd\nfrom pandas.io.json import json_normalize\n\n# Sample JSON object\njson_data = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"address\": {\n        \"street\": \"123 Main St\",\n        \"city\": \"New York\",\n        \"state\": \"NY\"\n    },\n    \"hobbies\": [\"reading\", \"sports\"],\n    \"friends\": [\n        {\n            \"name\": \"Jane\",\n            \"age\": 28\n        },\n        {\n            \"name\": \"Mike\",\n            \"age\": 32\n        }\n    ]\n}\n\n# Convert JSON object to Pandas DataFrame\ndf = json_normalize(json_data)\n\n# Print the DataFrame\nprint(df)", "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list using the bubble sort algorithm.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)  # Number of elements in the list\n    sorted_arr = list(arr)  # Create a copy of the original list\n    \n    # Iterate through the list until it is sorted\n    for i in range(n):\n        swapped = False  # Flag variable to optimize the sorting process\n        \n        # Iterate through the list from index 0 to n-i-1\n        # (The last i elements are already in place)\n        for j in range(0, n-i-1):\n            \n            # Compare adjacent elements and swap them if they are in the wrong order\n            if sorted_arr[j] > sorted_arr[j+1]:\n                sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j]\n                swapped = True  # Set the flag variable to True\n                \n        # If no swaps were made in a pass, the list is already sorted\n        if not swapped:\n            break\n    \n    return sorted_arr\n\n# Test the bubble_sort function with the given list\noriginal_list = [36, 71, 16, 21, 73, 5, 99, 42, 12, 67, 24, 88]\nprint(\"Original list:\", original_list)\n\nsorted_list = bubble_sort(original_list)\nprint(\"Sorted list:\", sorted_list)", "def calculate_final_price(original_price, tax_percentage, concession_percentage):\n    # Calculate service tax amount\n    tax_amount = original_price * (tax_percentage / 100.0)\n    \n    # Calculate the price after adding tax\n    price_after_tax = original_price + tax_amount\n    \n    # Calculate the concession amount\n    concession_amount = price_after_tax * (concession_percentage / 100.0)\n    \n    # Deduct the concession from the price\n    final_price = price_after_tax - concession_amount\n    \n    # Return the final price\n    return final_price", "def partition(array, low, high, indexes):\n    i = low - 1\n    pivot = array[indexes[high]]\n\n    for j in range(low, high):\n        if array[indexes[j]] <= pivot:\n            i += 1\n            indexes[i], indexes[j] = indexes[j], indexes[i]\n\n    indexes[i+1], indexes[high] = indexes[high], indexes[i+1]\n    return (i+1)\n\ndef quickSort(array, low, high, indexes):\n    if low < high:\n        pi = partition(array, low, high, indexes)\n        quickSort(array, low, pi-1, indexes)\n        quickSort(array, pi+1, high, indexes)\n\ndef sortEvenNumbers(array):\n    try:\n        indexes = [i for i, num in enumerate(array) if num % 2 == 0]\n        quickSort(array, 0, len(indexes)-1, indexes)\n\n        output = array.copy()\n        for i, index in enumerate(indexes):\n            output[index] = array[indexes[i]]\n\n        print(\"Sorted array is: \", output)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\ninputArray = [12, -6, 47, 18, 0, -3]\nsortEvenNumbers(inputArray)", "import logging\n\nclass LoggingConfigurator:\n    def __init__(self, config):\n        self.config = config\n        self.handlers = {}\n\n    def add_handler(self, handler_name, handler_settings):\n        self.handlers[handler_name] = handler_settings\n\n    def set_level(self, handler_name, level):\n        if handler_name in self.handlers:\n            self.handlers[handler_name]['level'] = level\n        else:\n            raise ValueError(f\"Handler '{handler_name}' does not exist.\")\n\n    def configure_logging(self):\n        for handler_name, settings in self.handlers.items():\n            handler_class = settings.get('class')\n            level = settings.get('level')\n            formatter = settings.get('formatter')\n\n            if handler_class == 'logging.StreamHandler':\n                handler = logging.StreamHandler()\n            elif handler_class == 'logging.FileHandler':\n                handler = logging.FileHandler('app.log')\n            else:\n                raise ValueError(f\"Unsupported handler class: {handler_class}\")\n\n            handler.setLevel(getattr(logging, level))\n            handler.setFormatter(logging.Formatter(formatter))\n            logging.getLogger().addHandler(handler)\n\n# Example usage\nconfig = {\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'class': 'logging.StreamHandler',\n            'formatter': 'console'\n        },\n        'null': {\n            'level': 'DEBUG',\n            'class': 'logging.NullHandler'\n        }\n    }\n}\n\nlogger_configurator = LoggingConfigurator(config)\nlogger_configurator.add_handler('console', config['handlers']['console'])\nlogger_configurator.add_handler('null', config['handlers']['null'])\nlogger_configurator.set_level('console', 'INFO')\nlogger_configurator.configure_logging()\n\n# Now the logging system is configured based on the provided settings\n# Logs will be written to console with INFO level and /dev/null with DEBUG level", "num_list = []\nnum = 100\n\nwhile num >= 0:\n    if num % 4 == 0 and num % 3 != 0 and num % 7 != 0:\n        num_list.append(num)\n    num -= 1\n\nnum_list.sort(reverse=True)\nsum_of_nums = sum(num_list)\n\nprint(num_list)\nprint(sum_of_nums)", "class StringManipulator:\n    def __init__(self, string):\n        self.string = string\n\n    def capitalize_first_letter(self):\n        self.string = self.string.capitalize()\n\n    def reverse_capitalization(self):\n        reversed_string = ''\n        for char in self.string:\n            if char.isalpha():\n                if char.isupper():\n                    reversed_string += char.lower()\n                else:\n                    reversed_string += char.upper()\n            else:\n                reversed_string += char\n        self.string = reversed_string\n\n    def count_character(self, char):\n        return self.string.count(char)", "class Node: \n    def __init__(self, key): \n        self.data = key  \n        self.left = None\n        self.right = None\n\ndef compute_tree_height(node): \n    if node is None: \n        return -1;   \n    else :\n        # Compute the depth of each subtree and use recursion\n        left_depth = compute_tree_height(node.left) \n        right_depth = compute_tree_height(node.right) \n   \n        # Use the larger one \n        if (left_depth > right_depth): \n            return left_depth+1\n        else: \n            return right_depth+1\n  \n# Driver code to test above\nroot = Node(1) \nroot.left = Node(2) \nroot.right = Node(3) \nroot.left.left = Node(4) \nroot.left.right = Node(5) \n  \nprint (\"Height of the binary tree is: %d\" %(compute_tree_height(root))) ", "import requests\nfrom bs4 import BeautifulSoup\n\nURL = \"https://docs.python.org/3/tutorial/\"\n\nr = requests.get(URL)\n\nsoup = BeautifulSoup(r.content, 'html5lib') \n\nheadings = soup.find_all(['h1', 'h2','h3'])\n\nfor heading in headings:\n    print(heading.text.strip())", "import random\n\n# Generate a random integer between 3 and 10\nn = random.randint(3, 10)\n\n# Create a list with elements 0-9 repeated n times\nlst = [i for i in range(10) for _ in range(n)]\n\nprint(lst)"], "preds": ["This small script demonstrates converting a nested JSON-like Python object into a flat Pandas DataFrame: it expects as input either a Python dict or a list-of-dicts (typically obtained from json.load or an API) and uses pandas' JSON-normalization utility to produce a DataFrame that flattens nested dictionaries into column names (e.g., address.street) and preserves nested lists as list-valued cells by default; the output is a DataFrame (printed to stdout) suitable for tabular analysis or further ETL. Core components and behaviors to implement or adapt: use pandas.json_normalize (note pandas.io.json.json_normalize is deprecated) on the loaded JSON; when the JSON contains nested arrays of primitive values those will remain list cells unless you explicitly expand them, and when you need one row per nested object (e.g., friends array) supply record_path and meta arguments to json_normalize to explode arrays into multiple rows while carrying parent fields as metadata; customize the sep parameter to change the nested-field column naming, and handle missing keys, type casting, and large inputs by pre-flattening or streaming JSON, using pd.read_json for simple top-level arrays, and post-processing column dtypes and nulls as required for downstream uses.", "This code implements a classic bubble-sort routine intended to produce a sorted version of a Python list while leaving the original input unchanged; it is suitable for small arrays, teaching, or situations where simplicity and stability are more important than performance. The function accepts a single argument, a sequence of comparable elements (elements must support the > operator), and returns a new list containing the elements in non-decreasing order; internally it makes a shallow copy of the input and then runs the standard pairwise adjacent-swap algorithm: for i from 0 to n-1, iterate j from 0 to n-i-2, compare element j and j+1 and swap if out of order, and set a swapped flag; if a complete pass produces no swaps, break early (best-case linear time). Key technical specifications: stable sort, worst- and average-case time complexity O(n^2), best-case O(n) when already sorted due to the early-exit optimization, space complexity O(n) in this implementation because of the input copy (can be made in-place with O(1) extra space by removing the copy), and the inner loop bound shrinks each outer iteration because the largest elements \"bubble\" to the end. Practical adaptations include adding a reverse/descending flag, a key or comparator argument for non-primitive types, converting to an in-place variant by mutating the input, or replacing the inner loop bounds with a last-swap sentinel to reduce passes; the module-level demonstration prints the original and returned sorted lists.", "This function is a small, pure utility to compute a final payable price by applying a percentage-based tax to an original amount and then applying a percentage-based concession (discount) to the taxed amount; it takes three numeric inputs\u2014original_price (monetary amount), tax_percentage (e.g., 10 for 10%), and concession_percentage (e.g., 5 for 5%)\u2014and returns a numeric final_price computed as: tax_amount = original_price * (tax_percentage/100), price_after_tax = original_price + tax_amount, concession_amount = price_after_tax * (concession_percentage/100), final_price = price_after_tax - concession_amount. Intended use cases are billing, invoicing, or checkout calculations where tax is applied before discounts that are calculated on the taxed total. Core implementation considerations: treat inputs as numeric (prefer Decimal for financial accuracy), validate ranges (percentages typically 0\u2013100 unless surcharges/negative discounts are explicit), define rounding rules (e.g., round to two decimal places using banker's or specified rounding), and document whether concession is applied to taxed amount (current behavior) or to original amount (allow an option/flag if needed). Adaptations commonly needed in production include supporting multiple taxes/fees, configuring calculation order (tax-first vs discount-first), optional inclusive/exclusive tax modes, returning a breakdown object (tax_amount, concession_amount, price_after_tax, final_price) for UI/display, and adding unit tests and error handling for invalid inputs.", "This module is intended to sort only the even numbers contained in an integer array while leaving odd entries in their original positions; it extracts the indices of even elements, uses an index-based quicksort to order those indices by the values they point to, and then reconstructs a new array with the sorted even values placed back into the even-element positions. Key components: sortEvenNumbers(array) (public entry) that builds indexes = [i for i,num in enumerate(array) if num%2==0], calls quickSort(array, 0, len(indexes)-1, indexes), and then builds a copy of the input with sorted even values reinserted; quickSort and partition implement in-place quicksort over the indexes list (partition picks pivot = array[indexes[high]] and swaps entries of the indexes list so that array[indexes] becomes ordered). Inputs/outputs and behavior: input is a list of integers, output is printed via print(\"Sorted array is: \", output) and the function returns None; the algorithm only reorders even numbers, preserves odds and original size, handles negatives and zero correctly, and wraps the process in a broad exception handler. Complexity: time O(k log k) average (k = number of even elements), worst-case O(k^2) for quicksort pivot choices, auxiliary space O(n) for the indexes list and output copy; recursion depth is O(k) (watch Python recursion limits for large k). Implementation/adaptation notes: the index-based quicksort treats indexes as a permutation vector and is useful when you need to reorder values indirectly without moving the full array during sorting; however the provided reconstruction contains a bug \u2014 after sorting the indexes you must map sorted values back to the original even positions (e.g., keep even_positions = original indexes list before sorting and then assign output[pos] = array[sorted_indexes[i]] for i,pos in enumerate(even_positions)), or simpler and safer use Python built-ins: sorted_vals = sorted(array[i] for i in even_positions) then place sorted_vals back into even_positions. Also consider using an iterative sort or Python's Timsort (sorted with key) to avoid recursion depth issues and to make the code simpler and more robust.", "This module implements a small configurable logging bootstrapper: a LoggingConfigurator class that accepts a configuration object and lets callers register named handler configurations, change their log levels, and then instantiate and attach concrete logging.Handler instances to the root Python logger; its intended use is to centralize and programmatically apply log handler setup (console/file/etc.) from code or a higher-level config structure. Core components and behavior: LoggingConfigurator stores a mapping of handler_name -> handler_settings (added via add_handler), supports updating a stored handler's 'level' via set_level (raises ValueError if the name is unknown), and provides configure_logging which iterates the stored handlers, maps a settings['class'] string to a concrete handler implementation, constructs the handler, sets its level using getattr(logging, level_string), assigns a Formatter created from settings['formatter'], and registers the handler on logging.getLogger() (the root logger). Important technical details for reimplementation: the settings dict should contain at minimum 'class' (string), 'level' (string matching logging constants like \"DEBUG\", \"INFO\") and 'formatter' (a format string or key you resolve to a logging.Formatter); configure_logging currently supports two concrete classes (maps 'logging.StreamHandler' to logging.StreamHandler() and 'logging.FileHandler' to logging.FileHandler('app.log')) and will raise ValueError for unsupported class names; level lookup uses getattr(logging, level_name) and will raise on invalid names; handlers are attached to the root logger without changing the root logger's level or de-duplicating existing handlers. Recommendations for practical adaptation: extend the class-name-to-constructor mapping to accept more handlers and constructor parameters (e.g., file path, mode, stream), allow passing prebuilt logging.Formatter instances or a formatter registry rather than raw strings, set or expose the root logger level, avoid re-attaching duplicate handlers, validate level names and handler parameters with clear errors, and consider accepting configuration as a single dict at initialization or from a file so the configurator can build handlers automatically.", "This code builds and prints a descending list of integers between 0 and 100 (inclusive) that are multiples of 4 but are not multiples of 3 or 7, then prints the sum of that list; it does this by iterating the integer range, filtering with modulo checks, collecting matches, sorting the collection in reverse order and summing it. Inputs and outputs: the only configurable input in the provided snippet is the upper bound (hard-coded as 100); the outputs are a Python list of ints (printed) and an integer sum (printed). Core components and behavior: a loop over integers with three modular predicates (divisible by 4, not divisible by 3, not divisible by 7), an append-based accumulator, an explicit reverse sort, and a sum aggregation; note that 0 is excluded by these predicates because 0 % 3 == 0 and 0 % 7 == 0. Complexity is O(n) for the scan plus O(m log m) for sorting (m matches), and memory is O(m). Implementation/adaptation guidance: for reuse wrap into a function taking parameters upper_bound, include_zero flag, required_divisor(s) and excluded_divisors, return (list, sum) instead of printing, or avoid the sort by iterating descending with range(start, -1, -step) or by stepping by 4 from the highest multiple to produce a naturally descending sequence (reducing cost to O(n) time and O(1) extra work); for large ranges prefer generators or incremental summation to reduce memory, and add input validation (integers, nonnegative bounds) and unit tests for correctness.", "This code implements a small mutable string utility class, StringManipulator, intended for simple text transformations and counts in scripts, CLI tools, or preprocessing pipelines: it stores a single Python str as internal state (set at construction) and exposes three operations \u2014 capitalize_first_letter() which mutates the internal string to have its first character uppercased and the remainder lowercased (Python str.capitalize semantics), reverse_capitalization() which produces a new string by toggling the case of every alphabetic character (upper -> lower, lower -> upper) while leaving non-alphabetic characters unchanged and then replaces the internal string with that result, and count_character(char) which returns an integer count of occurrences of the given substring/character in the current internal string (delegating to str.count). All transformation methods operate in O(n) time and use O(n) additional memory for the rebuilt string; the API currently mutates state except for the count method which is read-only. To reimplement or adapt: treat the constructor argument as a required str, validate inputs (raise TypeError for non-str), implement reverse_capitalization by iterating characters and using language-native isalpha/isupper/islower checks (or Unicode-aware equivalents) and building a result with a list + join for performance, implement capitalize by applying first-char upper + rest lower or using a built-in capitalize, and implement count using the platform's substring counting routine; consider optional enhancements such as returning transformed strings instead of mutating, adding case-insensitive counting, locale/Unicode normalization, explicit docstrings/type hints, and thread-safety if shared across threads.", "This code implements a simple binary tree node structure and a recursive function to compute the tree height (the length of the longest root-to-leaf path measured in edges). The Node abstraction contains a stored value and left/right child pointers; the function compute_tree_height(node) has the signature Node|None -> int, treats the empty subtree as height -1 (so a single-node tree has height 0), and computes the height by recursively obtaining left and right subtree heights and returning max(left_height, right_height) + 1. Intended use is to determine tree depth in algorithms or tests; it visits each node exactly once (O(n) time) and uses O(h) call-stack space where h is tree height, with the empty-tree and single-node cases handled by the base case. To reimplement, provide a similar Node type (value, left, right), implement the recursive base case returning -1 for None and otherwise return max(rec(left), rec(right)) + 1; adapt the base-case convention (return 0 for None) if you prefer height measured in nodes rather than edges, or replace recursion with an iterative BFS/level-order approach to avoid deep recursion.", "A small Python utility that fetches an HTML page and extracts top-level headings for simple content discovery: it performs an HTTP GET against a configured URL (constant string input), parses the retrieved HTML with BeautifulSoup (using the html5lib parser), locates all h1/h2/h3 elements, normalizes their text via .text.strip(), and emits them to stdout (one per line). Intended use cases are quick one-off scraping of table-of-contents or section titles from documentation or blog pages, building a lightweight index of headings, or feeding heading text to downstream tools. Core components and requirements: the requests library for network I/O, BeautifulSoup (bs4) and an HTML parser such as html5lib (or lxml) for robust parsing; the code should check HTTP status and handle network timeouts/retries, set a User-Agent header, and respect robots.txt and rate limits when used at scale. Implementation notes for re\u2011implementation: accept the target URL as a parameter, call requests.get(url, timeout=...) and r.raise_for_status(), construct BeautifulSoup(r.content, parser=\"html5lib\"), use soup.find_all(['h1','h2','h3']) to get Tag elements, extract and normalize text, and return or serialize results (print, list, JSON, or file). For production use, add error handling, session reuse, concurrency control, output formatting options, and configurable tag selectors or CSS selectors to adapt to other sites.", "This small Python utility generates a deterministic-size synthetic integer list for testing or sampling: it picks a random repeat count n in the inclusive range [3,10] and constructs a list of integers 0..9 where each integer value i appears consecutively n times (i.e., [0 repeated n times, 1 repeated n times, \u2026, 9 repeated n times]), producing a list of length 10*n (30..100 items) and prints it to stdout. Key technical points: it uses random.randint for a single uniform integer draw (seedable via random.seed for reproducibility), range(10) to enumerate values 0\u20139, a nested-comprehension to repeat each value n times, and returns a list of Python ints; time and memory are O(n*10). Typical uses include creating controlled frequency distributions, toy datasets for algorithms, or inputs to shuffling/sampling/histogram tests. To adapt, change the value range or repeat bounds, reverse the comprehension nesting to repeat the 0..9 sequence n times (or use list multiplication or itertools.repeat/chain for different repetition semantics), or add random.shuffle when a randomized ordering is required."]}